"""GitHub - CLI Commands (SAP-043)

Command implementations for CLI interface. Each command translates
CLI arguments to core service calls and formats output.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import asyncio
from uuid import UUID

import click
from github.core import (
    GithubError,
    GithubFilter,
    GithubNotFoundError,
    GithubRequest,
    GithubStatus,
    GithubValidationError,
)

from .formatters import (
    OutputFormat,
    print_entity,
    print_entity_list,
    print_error,
    print_output,
    print_success,
)


# ============================================================================
# Helper: Async Command Wrapper
# ============================================================================


def async_command(f):
    """Decorator to run async commands in event loop."""

    def wrapper(*args, **kwargs):
        return asyncio.run(f(*args, **kwargs))

    return wrapper


# ============================================================================
# Create Command
# ============================================================================


@click.command(name="create")
@click.argument("name")
@click.option("--description", "-d", help="Optional description")
@click.option(
    "--metadata",
    "-m",
    multiple=True,
    help="Metadata key=value pairs (can be specified multiple times)",
)
@click.pass_context
@async_command
async def create_command(
    ctx: click.Context, name: str, description: str | None, metadata: tuple
):
    """Create a new github entity.

    Example:
        github create "My Task" -d "Description" -m priority=high -m tags=important
    """
    format = ctx.obj["format"]
    service = ctx.obj["service"]

    try:
        # Parse metadata
        metadata_dict = {}
        for item in metadata:
            if "=" in item:
                key, value = item.split("=", 1)
                metadata_dict[key] = value
            else:
                print_error(f"Invalid metadata format: {item}. Use key=value", format)
                ctx.exit(1)

        # Create request
        request = GithubRequest(
            name=name, description=description, metadata=metadata_dict
        )

        # Call service
        response = await service.create(request)

        # Output result
        if format == OutputFormat.TABLE:
            print_success(response.message, format)
            print_entity(response.entity.to_dict(), format)
        else:
            print_output(response.entity.to_dict(), format)

    except GithubValidationError as e:
        print_error(f"Validation error: {e.message}", format)
        ctx.exit(1)
    except GithubError as e:
        print_error(f"Error: {e.message}", format)
        ctx.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e!s}", format)
        ctx.exit(1)


# ============================================================================
# Get Command
# ============================================================================


@click.command(name="get")
@click.argument("entity_id")
@click.pass_context
@async_command
async def get_command(ctx: click.Context, entity_id: str):
    """Get a github entity by ID.

    Example:
        github get 123e4567-e89b-12d3-a456-426614174000
    """
    format = ctx.obj["format"]
    service = ctx.obj["service"]

    try:
        # Parse UUID
        try:
            uuid = UUID(entity_id)
        except ValueError:
            print_error(f"Invalid UUID: {entity_id}", format)
            ctx.exit(1)

        # Call service
        entity = await service.get(uuid)

        # Output result
        print_entity(entity.to_dict(), format)

    except GithubNotFoundError as e:
        print_error(f"Not found: {e.message}", format)
        ctx.exit(1)
    except GithubError as e:
        print_error(f"Error: {e.message}", format)
        ctx.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e!s}", format)
        ctx.exit(1)


# ============================================================================
# List Command
# ============================================================================


@click.command(name="list")
@click.option(
    "--status",
    "-s",
    type=click.Choice([s.value for s in GithubStatus], case_sensitive=False),
    help="Filter by status",
)
@click.option("--name-contains", "-n", help="Filter by name containing text")
@click.option("--offset", type=int, default=0, help="Pagination offset (default: 0)")
@click.option("--limit", type=int, default=100, help="Maximum results (default: 100)")
@click.pass_context
@async_command
async def list_command(
    ctx: click.Context,
    status: str | None,
    name_contains: str | None,
    offset: int,
    limit: int,
):
    """List github entities with optional filtering.

    Example:
        github list
        github list --status active
        github list --name-contains "important" --limit 10
    """
    format = ctx.obj["format"]
    service = ctx.obj["service"]

    try:
        # Build filters
        filters = GithubFilter(
            status=GithubStatus(status) if status else None,
            name_contains=name_contains,
            offset=offset,
            limit=limit,
        )

        # Call service
        response = await service.list(filters)

        # Output result
        if format == OutputFormat.TABLE:
            if response.total == 0:
                click.echo("No entities found.")
            else:
                # Show summary
                click.echo(
                    f"Showing {len(response.entities)} of {response.total} total entities\n"
                )

                # Show table
                entities_dict = [e.to_dict() for e in response.entities]
                columns = ["id", "name", "status", "created_at"]
                print_entity_list(entities_dict, format, columns)

                # Show pagination info if needed
                if response.total > offset + len(response.entities):
                    click.echo(f"\nUse --offset {offset + limit} to see more results")
        else:
            output = {
                "entities": [e.to_dict() for e in response.entities],
                "total": response.total,
                "offset": response.offset,
                "limit": response.limit,
            }
            print_output(output, format)

    except GithubValidationError as e:
        print_error(f"Validation error: {e.message}", format)
        ctx.exit(1)
    except GithubError as e:
        print_error(f"Error: {e.message}", format)
        ctx.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e!s}", format)
        ctx.exit(1)


# ============================================================================
# Update Command
# ============================================================================


@click.command(name="update")
@click.argument("entity_id")
@click.option("--name", help="New name")
@click.option("--description", "-d", help="New description")
@click.option(
    "--metadata",
    "-m",
    multiple=True,
    help="Metadata key=value pairs (replaces existing)",
)
@click.pass_context
@async_command
async def update_command(
    ctx: click.Context,
    entity_id: str,
    name: str | None,
    description: str | None,
    metadata: tuple,
):
    """Update a github entity.

    At least one update field must be provided.

    Example:
        github update 123e4567-e89b-12d3-a456-426614174000 --name "New Name"
        github update <id> -d "New description" -m priority=low
    """
    format = ctx.obj["format"]
    service = ctx.obj["service"]

    # Validate at least one field provided
    if not name and description is None and not metadata:
        print_error(
            "At least one update field must be provided (--name, --description, --metadata)",
            format,
        )
        ctx.exit(1)

    try:
        # Parse UUID
        try:
            uuid = UUID(entity_id)
        except ValueError:
            print_error(f"Invalid UUID: {entity_id}", format)
            ctx.exit(1)

        # Get existing entity
        existing = await service.get(uuid)

        # Build update request (use existing values if not provided)
        metadata_dict = {}
        if metadata:
            for item in metadata:
                if "=" in item:
                    key, value = item.split("=", 1)
                    metadata_dict[key] = value
                else:
                    print_error(
                        f"Invalid metadata format: {item}. Use key=value", format
                    )
                    ctx.exit(1)
        else:
            metadata_dict = existing.metadata

        request = GithubRequest(
            name=name if name else existing.name,
            description=(
                description if description is not None else existing.description
            ),
            metadata=metadata_dict,
        )

        # Call service
        response = await service.update(uuid, request)

        # Output result
        if format == OutputFormat.TABLE:
            print_success(response.message, format)
            print_entity(response.entity.to_dict(), format)
        else:
            print_output(response.entity.to_dict(), format)

    except GithubNotFoundError as e:
        print_error(f"Not found: {e.message}", format)
        ctx.exit(1)
    except GithubValidationError as e:
        print_error(f"Validation error: {e.message}", format)
        ctx.exit(1)
    except GithubError as e:
        print_error(f"Error: {e.message}", format)
        ctx.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e!s}", format)
        ctx.exit(1)


# ============================================================================
# Delete Command
# ============================================================================


@click.command(name="delete")
@click.argument("entity_id")
@click.option("--yes", "-y", is_flag=True, help="Skip confirmation prompt")
@click.pass_context
@async_command
async def delete_command(ctx: click.Context, entity_id: str, yes: bool):
    """Delete a github entity.

    Example:
        github delete 123e4567-e89b-12d3-a456-426614174000
        github delete <id> -y  # Skip confirmation
    """
    format = ctx.obj["format"]
    service = ctx.obj["service"]

    try:
        # Parse UUID
        try:
            uuid = UUID(entity_id)
        except ValueError:
            print_error(f"Invalid UUID: {entity_id}", format)
            ctx.exit(1)

        # Get entity (to show what will be deleted)
        entity = await service.get(uuid)

        # Confirm deletion
        if not yes and format == OutputFormat.TABLE:
            click.echo(f"Entity to delete: {entity.name} ({entity.id})")
            if not click.confirm("Are you sure you want to delete this entity?"):
                click.echo("Deletion cancelled.")
                ctx.exit(0)

        # Call service
        await service.delete(uuid)

        # Output result
        print_success(f"Entity {entity_id} deleted successfully", format)

    except GithubNotFoundError as e:
        print_error(f"Not found: {e.message}", format)
        ctx.exit(1)
    except GithubError as e:
        print_error(f"Error: {e.message}", format)
        ctx.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e!s}", format)
        ctx.exit(1)


# ============================================================================
# Status Command
# ============================================================================


@click.command(name="status")
@click.argument("entity_id")
@click.argument(
    "new_status",
    type=click.Choice([s.value for s in GithubStatus], case_sensitive=False),
)
@click.pass_context
@async_command
async def status_command(ctx: click.Context, entity_id: str, new_status: str):
    """Update entity status.

    Example:
        github status 123e4567-e89b-12d3-a456-426614174000 active
        github status <id> completed
    """
    format = ctx.obj["format"]
    service = ctx.obj["service"]

    try:
        # Parse UUID
        try:
            uuid = UUID(entity_id)
        except ValueError:
            print_error(f"Invalid UUID: {entity_id}", format)
            ctx.exit(1)

        # Convert status string to enum
        status_enum = GithubStatus(new_status.lower())

        # Call service
        response = await service.update_status(uuid, status_enum)

        # Output result
        if format == OutputFormat.TABLE:
            print_success(response.message, format)
            print_entity(response.entity.to_dict(), format)
        else:
            print_output(response.entity.to_dict(), format)

    except GithubNotFoundError as e:
        print_error(f"Not found: {e.message}", format)
        ctx.exit(1)
    except GithubValidationError as e:
        print_error(f"Validation error: {e.message}", format)
        ctx.exit(1)
    except GithubError as e:
        print_error(f"Error: {e.message}", format)
        ctx.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e!s}", format)
        ctx.exit(1)


# ============================================================================
# Health Command
# ============================================================================


@click.command(name="health")
@click.pass_context
@async_command
async def health_command(ctx: click.Context):
    """Check service health status.

    Example:
        github health
    """
    format = ctx.obj["format"]
    service = ctx.obj["service"]

    try:
        # Call service health check
        health = await service.health_check()

        # Output result
        if format == OutputFormat.TABLE:
            click.echo("Service Health Status:")
            for key, value in health.items():
                formatted_key = key.replace("_", " ").title()
                click.echo(f"  {formatted_key}: {value}")
        else:
            print_output(health, format)

    except GithubError as e:
        print_error(f"Error: {e.message}", format)
        ctx.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e!s}", format)
        ctx.exit(1)


# ============================================================================
# Command Group Export
# ============================================================================


# Export for registration in __init__.py
cli = click.Group()
