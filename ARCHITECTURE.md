---
title: GitHub - Architecture
type: architectural-analysis
status: active
last_updated: '2025-11-14'
---

# GitHub - Architecture

**Version**: 0.1.0
**Generated by**: chora-base SAP-047 (Capability Server Template)
**Last Updated**: 2025-11-13

---

## Overview

This document provides a deep dive into the architecture, design patterns, and implementation details of the GitHub capability server.

**Key Principles**:
- ðŸŽ¯ **Core/Interface Separation** (SAP-042) - Business logic independent of interfaces
- ðŸ”Œ **Multi-Interface Support** (SAP-043) - CLI, REST from single core
- ðŸ“¦ **Dependency Injection** - Testable, swappable components
- ðŸ›¡ï¸ **Type Safety** - Pydantic models with full type hints
- âœ… **Test Coverage** - 85%+ coverage target

---

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Interfaces Layer                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚   CLI    â”‚  â”‚   REST   â”‚                         â”‚
â”‚  â”‚ (Click)  â”‚  â”‚(FastAPI) â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚       â”‚             â”‚                                          â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                     â”‚                                           â”‚
â”‚                     â–¼                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚                 Core Layer                       â”‚          â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚          â”‚
â”‚  â”‚  â”‚  Models  â”‚  â”‚ Services â”‚  â”‚Exceptionsâ”‚      â”‚          â”‚
â”‚  â”‚  â”‚(Pydantic)â”‚  â”‚ (Logic)  â”‚  â”‚(Errors)  â”‚      â”‚          â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Layer

**Purpose**: Interface-agnostic business logic

**Location**: `github/core/`

### Models (`models.py`)

**Pydantic Models** for domain entities with validation:

**Base Models**:
```python
class BaseModel(pydantic.BaseModel):
    """Shared configuration for all models."""

    model_config = ConfigDict(
        validate_assignment=True,
        str_strip_whitespace=True,
        use_enum_values=False
    )

class TimestampedModel(BaseModel):
    """Model with automatic timestamps."""

    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

**Domain Entity**:
```python
class GithubEntity(TimestampedModel):
    """Core domain entity."""

    id: UUID = Field(default_factory=uuid4)
    name: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=2000)
    status: GithubStatus = Field(default=GithubStatus.PENDING)
    metadata: Dict[str, Any] = Field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with ISO timestamps."""
        return {
            **self.model_dump(),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }
```

**Request/Response Models**:
- `GithubRequest` - Entity creation/update
- `GithubResponse` - Operation results
- `GithubFilter` - List filtering
- `GithubListResponse` - Paginated lists

**Design Decisions**:
- UUID for globally unique IDs
- ISO 8601 timestamps (UTC)
- Pydantic validation for type safety
- Metadata as flexible key-value store

---

### Services (`services.py`)

**Abstract Service Base**:
```python
class GithubServiceBase(ABC):
    """Abstract base for swappable implementations."""

    @abstractmethod
    async def create(self, request: GithubRequest) -> GithubResponse:
        """Create entity."""
        pass

    @abstractmethod
    async def get(self, entity_id: UUID) -> GithubEntity:
        """Get entity by ID."""
        pass

    # ... other CRUD operations
```

**In-Memory Implementation**:
```python
class GithubService(GithubServiceBase):
    """In-memory implementation (development/lightweight production)."""

    def __init__(self):
        self._storage: Dict[UUID, GithubEntity] = {}

    async def create(self, request: GithubRequest) -> GithubResponse:
        entity = GithubEntity(
            name=request.name,
            description=request.description,
            metadata=request.metadata
        )
        self._storage[entity.id] = entity
        return GithubResponse(
            success=True,
            message="Entity created successfully",
            entity=entity
        )
```

**Factory Function**:
```python
def create_github_service() -> GithubServiceBase:
    """Factory for dependency injection."""
    return GithubService()
```

**Design Decisions**:
- Abstract base for multiple implementations (in-memory, database, etc.)
- Factory pattern for dependency injection
- Async/await throughout for scalability
- Status transition validation
- In-memory storage for simplicity (swap with database as needed)

---

### Exceptions (`exceptions.py`)

**Exception Hierarchy**:
```
GithubError (Base)
â”œâ”€â”€ GithubValidationError (400)
â”œâ”€â”€ GithubNotFoundError (404)
â”œâ”€â”€ GithubConflictError (409)
â”œâ”€â”€ GithubPermissionError (403)
â”œâ”€â”€ GithubRateLimitError (429)
â”œâ”€â”€ GithubTimeoutError (504)
â””â”€â”€ GithubServiceError (500)
```

**Base Exception**:
```python
class GithubError(Exception):
    """Base exception with serialization."""

    def __init__(
        self,
        message: str,
        code: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None
    ):
        self.message = message
        self.code = code or self.__class__.__name__.upper()
        self.details = details or {}
        super().__init__(self.message)

    def to_dict(self) -> Dict[str, Any]:
        """Serialize for API responses."""
        return {
            "error": self.code,
            "message": self.message,
            "details": self.details
        }
```

**Design Decisions**:
- Machine-readable error codes
- Serializable for JSON APIs
- HTTP status code mapping
- Detailed error context in `details`

---

## Interface Layer

**Purpose**: Adapt core logic to specific interfaces

**Location**: `github/interfaces/`

### CLI Interface (`interfaces/cli/`)

**Framework**: Click

**Structure**:
- `__init__.py` - Click app setup, global options
- `commands.py` - Command definitions (create, get, list, update, delete, status, health)
- `formatters.py` - Output formatting (JSON, table, YAML)

**Key Pattern - Async Command Wrapper**:
```python
def async_command(f):
    """Wrapper to run async commands in Click."""
    @wraps(f)
    def wrapper(*args, **kwargs):
        return asyncio.run(f(*args, **kwargs))
    return wrapper

@click.command()
@async_command
async def create_command(ctx, name, description):
    service = ctx.obj["service"]
    request = GithubRequest(name=name, description=description)
    response = await service.create(request)
    print_entity(response.entity.to_dict(), ctx.obj["format"])
```

**Design Decisions**:
- Click for declarative CLI
- Async wrapper for core service calls
- Multiple output formats (JSON, table, YAML)
- Color-coded messages for UX
- Context object for shared state

---

### REST Interface (`interfaces/rest/`)

**Framework**: FastAPI

**Structure**:
- `__init__.py` - FastAPI app, CORS, middleware
- `routes.py` - API endpoints (9 endpoints)
- `models.py` - API-specific request/response models
- `middleware.py` - Exception-to-HTTP mapping

**Key Pattern - Exception Middleware**:
```python
async def error_handler_middleware(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except GithubValidationError as e:
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content=e.to_dict()
        )
    except GithubNotFoundError as e:
        return JSONResponse(
            status_code=status.HTTP_404_NOT_FOUND,
            content=e.to_dict()
        )
    # ... other exceptions
```

**Design Decisions**:
- FastAPI for automatic OpenAPI docs
- Exception middleware for consistent error handling
- CORS enabled for frontend integration
- Request duration tracking
- Dependency injection for service

---

## Testing Strategy

**Coverage Target**: 85%+

**Test Structure**:
```
tests/
â”œâ”€â”€ core/                    # Core logic tests
â”‚   â”œâ”€â”€ test_models.py       # Model validation, serialization
â”‚   â”œâ”€â”€ test_services.py     # CRUD operations, business logic
â”‚   â””â”€â”€ test_exceptions.py   # Exception hierarchy, serialization
â”œâ”€â”€ interfaces/              # Interface tests
â”‚   â”œâ”€â”€ test_cli.py          # CLI commands, output formats
â”‚   â”œâ”€â”€ test_rest.py         # REST endpoints, HTTP status codes
```

**Testing Frameworks**:
- `pytest` - Test runner
- `pytest-asyncio` - Async test support
- `pytest-cov` - Coverage measurement
- `Click.testing.CliRunner` - CLI testing
- `FastAPI.testclient.TestClient` - REST API testing

**Key Patterns**:
```python
# Async test
@pytest.mark.asyncio
async def test_create_entity():
    service = create_github_service()
    request = GithubRequest(name="Test")
    response = await service.create(request)
    assert response.success is True

# CLI test
def test_create_command(runner):
    result = runner.invoke(cli, ["create", "Test Entity"])
    assert result.exit_code == 0
    assert "created successfully" in result.output.lower()

# REST API test
def test_create_endpoint(client):
    response = client.post(
        "/api/v1/github/entities",
        json={"name": "Test Entity"}
    )
    assert response.status_code == 201
    assert response.json()["success"] is True
```

---

## Design Patterns

### 1. Core/Interface Separation (SAP-042)

**Problem**: Tight coupling between business logic and interfaces

**Solution**: Core layer with interface adapters

**Benefits**:
- Core logic testable without interfaces
- Add new interfaces without changing core
- Swap storage backends without touching interfaces

---

### 2. Dependency Injection

**Problem**: Hard-coded dependencies make testing difficult

**Solution**: Factory functions for service creation

```python
# Factory
def create_github_service() -> GithubServiceBase:
    return GithubService()

# Usage in interface
service = create_github_service()

# Testing with mock
def test_with_mock():
    service = Mock(spec=GithubServiceBase)
    # ...
```

---

### 3. Abstract Base Class

**Problem**: Want multiple implementations (in-memory, database, etc.)

**Solution**: Abstract base class with concrete implementations

**Benefits**:
- Swap implementations without changing interfaces
- Type safety via ABC
- Clear contract for implementations

---

### 4. Async/Await Throughout

**Problem**: Blocking I/O limits scalability

**Solution**: Async/await for all I/O operations

**Benefits**:
- Scalable to high concurrency
- Non-blocking database/API calls
- FastAPI async support

---

### 5. Factory Pattern

**Problem**: Service instantiation logic scattered

**Solution**: Factory functions centralize creation

**Benefits**:
- Single point of configuration
- Easy to swap implementations
- Testability via dependency injection

---

## Configuration

**Location**: `github/config/settings.py`

**Environment Variables**:
```python
class Settings(BaseSettings):
    """Application settings from environment."""

    log_level: str = Field(default="INFO", env="GITHUB_LOG_LEVEL")
    port: int = Field(default=8000, env="GITHUB_PORT")

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8"
    )
```

---

## Deployment

### Development

```bash
# CLI
github create "Task"

# REST API
uvicorn github.interfaces.rest:app --reload --port 8000

```

### Production

**Docker**:
```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY . .

RUN pip install --no-cache-dir .

EXPOSE 8000
CMD ["gunicorn", "github.interfaces.rest:app", \
     "-w", "4", "-k", "uvicorn.workers.UvicornWorker", \
     "--bind", "0.0.0.0:8000"]
```

**Docker Compose** (with database):
```yaml
services:
  github:
    build: .
    ports:
      - "8000:8000"
    environment:
      - GITHUB_LOG_LEVEL=INFO
    depends_on:
      - postgres

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=github
      - POSTGRES_PASSWORD=secret
```

---

## Performance Considerations

**In-Memory Storage**:
- âœ… Fast for development/testing
- âœ… Simple deployment (no database)
- âš ï¸ Not persistent across restarts
- âš ï¸ Limited scalability (single process)

**Scaling Strategies**:
1. **Horizontal**: Add database (PostgreSQL, MongoDB), share state
2. **Vertical**: Use gunicorn with multiple workers
3. **Caching**: Add Redis for hot data


---

## Security Considerations

**Current** (development):
- No authentication
- No authorization
- CORS allows all origins
- No rate limiting

**Production Recommendations**:
1. **Authentication**: Add JWT, API keys, or OAuth
2. **Authorization**: Role-based access control (RBAC)
3. **CORS**: Restrict to specific origins
4. **Rate Limiting**: Prevent abuse
5. **HTTPS**: TLS encryption in transit
6. **Input Validation**: Already implemented via Pydantic
7. **SQL Injection**: Not applicable (in-memory storage)

---

## Migration Paths

### From In-Memory to Database

**Step 1**: Implement new service class
```python
class GithubDatabaseService(GithubServiceBase):
    def __init__(self, db_url: str):
        self.engine = create_async_engine(db_url)

    async def create(self, request: GithubRequest) -> GithubResponse:
        async with self.session() as session:
            entity = GithubORM(name=request.name, ...)
            session.add(entity)
            await session.commit()
            return GithubResponse(success=True, entity=...)
```

**Step 2**: Update factory
```python
def create_github_service() -> GithubServiceBase:
    db_url = os.getenv("DATABASE_URL")
    if db_url:
        return GithubDatabaseService(db_url)
    return GithubService()  # Fallback to in-memory
```

**Benefits**:
- Zero changes to interfaces
- Gradual migration
- Backward compatible

---

## Monitoring & Observability

**Logging**:
```python
import logging

logger = logging.getLogger(__name__)

async def create(self, request):
    logger.info(f"Creating entity: {request.name}")
    # ...
    logger.debug(f"Created entity with ID: {entity.id}")
```

**Metrics** (with Prometheus):
```python
from prometheus_client import Counter, Histogram

entity_create_count = Counter("entity_create_total", "Total entities created")
request_duration = Histogram("request_duration_seconds", "Request duration")

@request_duration.time()
async def create(self, request):
    entity_create_count.inc()
    # ...
```

**Tracing** (with OpenTelemetry):
```python
from opentelemetry import trace

tracer = trace.get_tracer(__name__)

async def create(self, request):
    with tracer.start_as_current_span("create_entity"):
        # ...
```

---

## Related Documentation

- **[CLI.md](CLI.md)** - CLI reference
- **[API.md](API.md)** - REST API reference
- **[AGENTS.md](AGENTS.md)** - Agent awareness guide

---

## SAP References

- **SAP-042**: [Interface Design](https://github.com/anthropics/chora-base) - Core/interface separation
- **SAP-043**: [Multi-Interface](https://github.com/anthropics/chora-base) - CLI/REST/MCP patterns
- **SAP-047**: [Capability Server Template](https://github.com/anthropics/chora-base) - Template system

---

**Generated by**: chora-base SAP-047 Capability Server Template
