"""Tests for GitHub Core Services (SAP-042)

Tests verify service layer business logic, CRUD operations, validation,
and error handling.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

from datetime import datetime, timedelta
from uuid import uuid4

import pytest

from chora_github.core.exceptions import GithubNotFoundError, GithubValidationError
from chora_github.core.models import GithubFilter, GithubRequest, GithubStatus
from chora_github.core.services import GithubService, create_github_service


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def service():
    """Create a fresh service instance for each test."""
    return GithubService()


@pytest.fixture
def sample_request():
    """Create a sample request for testing."""
    return GithubRequest(
        name="Test Entity", description="Test description", metadata={"key": "value"}
    )


# ============================================================================
# Test Service Creation
# ============================================================================


class TestServiceFactory:
    """Test service factory function."""

    def test_create_service(self):
        """Test factory creates service instance."""
        service = create_github_service()
        assert service is not None
        assert isinstance(service, GithubService)


# ============================================================================
# Test Create Operation
# ============================================================================


class TestCreateOperation:
    """Test entity creation."""

    @pytest.mark.asyncio
    async def test_create_entity(self, service, sample_request):
        """Test creating a new entity."""
        response = await service.create(sample_request)

        assert response.success is True
        assert response.entity.name == sample_request.name
        assert response.entity.description == sample_request.description
        assert response.entity.status == GithubStatus.PENDING
        assert response.message is not None

    @pytest.mark.asyncio
    async def test_create_entity_generates_unique_id(self, service, sample_request):
        """Test each created entity gets unique ID."""
        response1 = await service.create(sample_request)
        response2 = await service.create(sample_request)

        assert response1.entity.id != response2.entity.id

    @pytest.mark.asyncio
    async def test_create_entity_with_minimal_data(self, service):
        """Test creating entity with only required fields."""
        request = GithubRequest(name="Minimal")
        response = await service.create(request)

        assert response.success is True
        assert response.entity.name == "Minimal"
        assert response.entity.description is None
        assert response.entity.metadata == {}


# ============================================================================
# Test Get Operation
# ============================================================================


class TestGetOperation:
    """Test entity retrieval."""

    @pytest.mark.asyncio
    async def test_get_existing_entity(self, service, sample_request):
        """Test retrieving an existing entity."""
        # Create entity
        create_response = await service.create(sample_request)
        entity_id = create_response.entity.id

        # Get entity
        entity = await service.get(entity_id)

        assert entity.id == entity_id
        assert entity.name == sample_request.name

    @pytest.mark.asyncio
    async def test_get_nonexistent_entity(self, service):
        """Test getting non-existent entity raises NotFoundError."""
        fake_id = uuid4()

        with pytest.raises(GithubNotFoundError) as exc_info:
            await service.get(fake_id)

        assert str(fake_id) in str(exc_info.value)


# ============================================================================
# Test List Operation
# ============================================================================


class TestListOperation:
    """Test entity listing and filtering."""

    @pytest.mark.asyncio
    async def test_list_empty(self, service):
        """Test listing when no entities exist."""
        response = await service.list()

        assert response.entities == []
        assert response.total == 0

    @pytest.mark.asyncio
    async def test_list_all_entities(self, service):
        """Test listing all entities."""
        # Create 3 entities
        for i in range(3):
            request = GithubRequest(name=f"Entity {i}")
            await service.create(request)

        # List all
        response = await service.list()

        assert len(response.entities) == 3
        assert response.total == 3

    @pytest.mark.asyncio
    async def test_list_with_status_filter(self, service, sample_request):
        """Test filtering by status."""
        # Create entities with different statuses
        entity1 = await service.create(sample_request)
        await service.update_status(entity1.entity.id, GithubStatus.ACTIVE)

        entity2 = await service.create(sample_request)
        # entity2 remains PENDING

        # Filter for ACTIVE
        filters = GithubFilter(status=GithubStatus.ACTIVE)
        response = await service.list(filters)

        assert response.total == 1
        assert response.entities[0].status == GithubStatus.ACTIVE

    @pytest.mark.asyncio
    async def test_list_with_name_filter(self, service):
        """Test filtering by name."""
        # Create entities
        await service.create(GithubRequest(name="Alpha"))
        await service.create(GithubRequest(name="Beta"))
        await service.create(GithubRequest(name="Alphabet"))

        # Filter by name containing "alpha"
        filters = GithubFilter(name_contains="alpha")
        response = await service.list(filters)

        assert response.total == 2
        names = [e.name for e in response.entities]
        assert "Alpha" in names
        assert "Alphabet" in names
        assert "Beta" not in names

    @pytest.mark.asyncio
    async def test_list_with_date_filters(self, service, sample_request):
        """Test filtering by creation date."""
        # Create entity
        await service.create(sample_request)

        # Filter for entities created in last hour
        one_hour_ago = datetime.utcnow() - timedelta(hours=1)
        filters = GithubFilter(created_after=one_hour_ago)
        response = await service.list(filters)

        assert response.total == 1

        # Filter for entities created tomorrow (should be 0)
        tomorrow = datetime.utcnow() + timedelta(days=1)
        filters = GithubFilter(created_after=tomorrow)
        response = await service.list(filters)

        assert response.total == 0

    @pytest.mark.asyncio
    async def test_list_with_pagination(self, service):
        """Test pagination."""
        # Create 10 entities
        for i in range(10):
            request = GithubRequest(name=f"Entity {i}")
            await service.create(request)

        # Get first page (5 items)
        filters = GithubFilter(offset=0, limit=5)
        response = await service.list(filters)

        assert len(response.entities) == 5
        assert response.total == 10
        assert response.offset == 0
        assert response.limit == 5

        # Get second page (5 items)
        filters = GithubFilter(offset=5, limit=5)
        response = await service.list(filters)

        assert len(response.entities) == 5
        assert response.total == 10

    @pytest.mark.asyncio
    async def test_list_sorted_by_created_at(self, service):
        """Test entities are sorted newest first."""
        # Create entities in sequence
        for i in range(3):
            request = GithubRequest(name=f"Entity {i}")
            await service.create(request)

        response = await service.list()

        # Should be sorted newest first (Entity 2, 1, 0)
        assert response.entities[0].name == "Entity 2"
        assert response.entities[1].name == "Entity 1"
        assert response.entities[2].name == "Entity 0"


# ============================================================================
# Test Update Operation
# ============================================================================


class TestUpdateOperation:
    """Test entity updates."""

    @pytest.mark.asyncio
    async def test_update_entity(self, service, sample_request):
        """Test updating an existing entity."""
        # Create entity
        create_response = await service.create(sample_request)
        entity_id = create_response.entity.id

        # Update entity
        update_request = GithubRequest(
            name="Updated Name",
            description="Updated description",
            metadata={"updated": True},
        )
        response = await service.update(entity_id, update_request)

        assert response.success is True
        assert response.entity.name == "Updated Name"
        assert response.entity.description == "Updated description"
        assert response.entity.metadata == {"updated": True}

    @pytest.mark.asyncio
    async def test_update_nonexistent_entity(self, service, sample_request):
        """Test updating non-existent entity raises NotFoundError."""
        fake_id = uuid4()

        with pytest.raises(GithubNotFoundError):
            await service.update(fake_id, sample_request)

    @pytest.mark.asyncio
    async def test_update_updates_timestamp(self, service, sample_request):
        """Test update modifies updated_at timestamp."""
        # Create entity
        create_response = await service.create(sample_request)
        entity_id = create_response.entity.id
        original_updated_at = create_response.entity.updated_at

        # Update entity
        update_request = GithubRequest(name="New Name")
        response = await service.update(entity_id, update_request)

        assert response.entity.updated_at > original_updated_at


# ============================================================================
# Test Delete Operation
# ============================================================================


class TestDeleteOperation:
    """Test entity deletion."""

    @pytest.mark.asyncio
    async def test_delete_entity(self, service, sample_request):
        """Test deleting an existing entity."""
        # Create entity
        create_response = await service.create(sample_request)
        entity_id = create_response.entity.id

        # Delete entity
        await service.delete(entity_id)

        # Verify deleted
        with pytest.raises(GithubNotFoundError):
            await service.get(entity_id)

    @pytest.mark.asyncio
    async def test_delete_nonexistent_entity(self, service):
        """Test deleting non-existent entity raises NotFoundError."""
        fake_id = uuid4()

        with pytest.raises(GithubNotFoundError):
            await service.delete(fake_id)


# ============================================================================
# Test Status Update Operation
# ============================================================================


class TestStatusUpdateOperation:
    """Test entity status transitions."""

    @pytest.mark.asyncio
    async def test_update_status_pending_to_active(self, service, sample_request):
        """Test valid status transition: PENDING → ACTIVE."""
        # Create entity (starts as PENDING)
        create_response = await service.create(sample_request)
        entity_id = create_response.entity.id

        # Update to ACTIVE
        response = await service.update_status(entity_id, GithubStatus.ACTIVE)

        assert response.entity.status == GithubStatus.ACTIVE

    @pytest.mark.asyncio
    async def test_update_status_active_to_completed(self, service, sample_request):
        """Test valid status transition: ACTIVE → COMPLETED."""
        # Create and activate entity
        create_response = await service.create(sample_request)
        entity_id = create_response.entity.id
        await service.update_status(entity_id, GithubStatus.ACTIVE)

        # Update to COMPLETED
        response = await service.update_status(entity_id, GithubStatus.COMPLETED)

        assert response.entity.status == GithubStatus.COMPLETED

    @pytest.mark.asyncio
    async def test_update_status_invalid_transition(self, service, sample_request):
        """Test invalid status transition raises ValidationError."""
        # Create and complete entity
        create_response = await service.create(sample_request)
        entity_id = create_response.entity.id
        await service.update_status(entity_id, GithubStatus.ACTIVE)
        await service.update_status(entity_id, GithubStatus.COMPLETED)

        # Try to transition from COMPLETED (terminal state)
        with pytest.raises(GithubValidationError) as exc_info:
            await service.update_status(entity_id, GithubStatus.ACTIVE)

        assert "Invalid status transition" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_update_status_nonexistent_entity(self, service):
        """Test updating status of non-existent entity."""
        fake_id = uuid4()

        with pytest.raises(GithubNotFoundError):
            await service.update_status(fake_id, GithubStatus.ACTIVE)


# ============================================================================
# Test Health Check
# ============================================================================


class TestHealthCheck:
    """Test service health check."""

    @pytest.mark.asyncio
    async def test_health_check(self, service, sample_request):
        """Test health check returns status."""
        # Create some entities
        await service.create(sample_request)
        await service.create(sample_request)

        health = await service.health_check()

        assert health["status"] == "healthy"
        assert health["entity_count"] == 2
        assert "timestamp" in health
